# volatile
## volatile的作用有哪些？

Volatile第一变量相当于告诉编译器这个变量的值会随时发生变化，每次使用之前都要去内存里重新读取它的值，并不要随意针对它做优化，主要用在：

1. 一个中断子程序中会访问到的非自动变量
2. 多线程应用中被几个线程共享的变量；
3. 并行设备的硬件寄存器。

## 几个相关的问题

- 一个参数既可以是const还可以是volatile吗？解释为什么。
> 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

- 一个指针可以是volatile 吗？解释为什么。
> 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。

- 下面的函数有什么错误：
```
int square(volatile int *ptr)
{
     return *ptr * *ptr;
}
```
> 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：
```c
int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}
```
由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下
```
long square(volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

# static
## static关键字的作用有哪些？

- 在函数体中，一个被声明为静态的变量在这个变量在调用过程中维持其值不变；
- 在模块内（但在函数体外），一个被声明为静态的变量，可以被这个模块内的所用函数使用，但不能被模块外的函数使用，它是一个本地的全局变量；
- 在模块内，一个被声明为静态变量的函数，只能被这个模块内的函数调用。

## static全局变量与局部变量的区别
- static全局变量只能被初始化一次，防止其他单元文件中被引用；
- static局部变量与局部变量的区别：static局部变量只能被初始化一次，下一次依据上一次结果的值；

## static函数与普通函数的区别

- static在内存中只用一份
- 普通函数在每一次调用中维持一份拷贝。

# __interrupt

中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字  **__interrupt** 。下面的代码就使用了 **__interrupt** 关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码。

```
__interrupt double compute_area (double radius)
{
    double area = PI * radius * radius;
    printf(" Area = %f", area);
    return area;
}
```

这个函数有太多的错误了，以至让人不知从何说起了：
1. ISR 不能返回一个值。
2. ISR 不能传递参数。
3. 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
4. 与第三点一脉相承，printf()经常有重入和性能上的问题。

